from torch.autograd import Variable

import torch.nn as nn
import torch.onnx
import torchvision
import torch

class SimpleModel(nn.Module):
    def __init__(self, input_size, hidden_sizes, output_size):
        self.input_size = input_size
        self.output_size = output_size
        self.fcs = []  # List of fully connected layers
        in_size = input_size

model_pytorch = SimpleModel(input_size=224, hidden_sizes=3, output_size=224)
model_pytorch.load_state_dict(torch.load('./models/model_simple.pt'))

dummy_input = Variable(torch.randn(1, 3, 224, 224)) #dummy_input = torch.from_numpy(X_test[0].reshape(1, -1)).float().to(device)
#dummy_output = model_pytorch(dummy_input)
#print(dummy_output)

# Export to ONNX format
torch.onnx.export(model_pytorch, dummy_input, 'model_simple.onnx')




#python  train.py -data data/dgs -save_model model -keep_checkpoint 1 \
#          -layers 2 -rnn_size 512 -word_vec_size 512 -transformer_ff 2048 -heads 8  \
#          -encoder_type transformer -decoder_type transformer -position_encoding \
#          -max_generator_batches 2 -dropout 0.1 \
#          -early_stopping 3 -early_stopping_criteria accuracy ppl \
#          -batch_size 2048 -accum_count 3 -batch_type tokens -normalization tokens \
#          -optim adam -adam_beta2 0.998 -decay_method noam -warmup_steps 3000 -learning_rate 0.5 \
#         -max_grad_norm 0 -param_init 0  -param_init_glorot \
#          -label_smoothing 0.1 -valid_steps 100 -save_checkpoint_steps 100 \
#          -world_size 1 -gpu_ranks 0

